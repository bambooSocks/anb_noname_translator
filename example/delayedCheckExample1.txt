
[
	Local "A" (ANew "A" ["N1", "N2"]),
	Comm "A" "B" (Comp "h" [Atom "N1", Atom "N2"]),
	Comm "B" "A" (Atom "ok"),
	Comm "A" "B" (Comp "pair" [Atom "N1", Atom "N2"]),
	Comm "B" "A" (Atom "ok")
]

# in AnnB

Sigma0:
	ok

Actions:
A: new N1, N2
A -> B: h(N1, N2)
B -> A: ok
A -> B: pair(N1, N2)
B -> A: ok


# in NN

Cells:
	sessionTxn[S] := T1
	rcvX3[S] := 0
	rcvX4[S] := 0
	rcvX5[S] := 0
	rcvX8[S] := 0

Transaction T1:
	new(S).
	new(N1,N2).
	send(h(N1,N2)).
	send(S).
	nil

Transaction T2:
	receive(X3).
	receive(S).
	T := sessionTxn[S].
	if (T = T2) then
		rcvX3[S] := X3.
		send(ok).
		send(S).
		nil
	else nil

Transaction T3:
	receive(X4).
	receive(S).
	T := sessionTxn[S].
	if (T = T3) then
		rcvX4[S] := X4.
		send(pair(N1,N2)).
		send(S).
		nil
	else nil

Transaction T4:
	receive(X5).
	receive(S).
	T := sessionTxn[S].
	if (T = T4) then
		rcvX5[S] := X5.
		try X6=proj1(X5) in
			try X7=proj2(X5) in
				if X3=h(X6,X7) then // need to retrieve X3
					send(ok).
					send(S).
					nil
				else nil
			catch nil
		catch nil
	else nil

Transaction T5:
	receive(X8).
	receive(S).
	T := sessionTxn[S].
	if (T = T5) then
		rcvX8[S] := X8.
		nil
	else nil